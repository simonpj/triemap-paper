% Links
% https://stackoverflow.com/questions/16084788/generic-trie-haskell-implementation
% Hinze paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[format=sigplan]{acmart}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
% \acmJournal{PACMPL}
% \acmVolume{1}
% \acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
% \acmArticle{1}
% \acmYear{2020}
% \acmMonth{8}
% \acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
% \startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
% \setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%%% The following is specific to ICFP '20 and the paper
%%% 'Kinds Are Calling Conventions'
%%% by Paul Downen, Zena M. Ariola, Simon Peyton Jones, and Richard A. Eisenberg.
%%%
\setcopyright{rightsretained}
\acmPrice{}
\acmDOI{10.1145/3408986}
\acmYear{2020}
\copyrightyear{2020}
\acmSubmissionID{icfp20main-p93-p}
\acmJournal{PACMPL}
\acmVolume{4}
\acmNumber{ICFP}
\acmArticle{104}
\acmMonth{8}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amsthm}
% \usepackage{amssymb}
% \usepackage{stmaryrd}
\usepackage{framed}
\usepackage{proof}
\usepackage{braket}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[inline,shortlabels]{enumitem}
\usepackage[capitalize]{cleveref}
\usepackage{xcolor}
\usepackage{pgffor}
\usepackage{ragged2e}

% \RequirePackage{xargs}

\VerbatimFootnotes

\lstset{language=Haskell}

\let\restriction\relax

\theoremstyle{theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{property}{Property}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{restriction}{Restriction}
\newtheorem{intuition}{Intuition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}

%% Style guide forbids boxes around figures
% \newenvironment{figurebox}{\begin{figure}\begin{framed}}{\end{framed}\end{figure}}
% \newenvironment{figurebox*}{\begin{figure*}\begin{framed}}{\end{framed}\end{figure*}}
\newenvironment{figurebox}{\begin{figure}}{\end{figure}}
\newenvironment{figurebox*}{\begin{figure*}}{\end{figure*}}

\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Fig.}{Figs.}
\crefname{restriction}{Restriction}{Restrictions}

% Some colors:
\definecolor{dkcyan}{rgb}{0.1, 0.3, 0.3}
\definecolor{dkgreen}{rgb}{0,0.3,0}
\definecolor{olive}{rgb}{0.5, 0.5, 0.0}
\definecolor{dkblue}{rgb}{0,0.1,0.5}

\definecolor{col:ln}{rgb}  {0.1, 0.1, 0.7}
\definecolor{col:str}{rgb} {0.8, 0.0, 0.0}
\definecolor{col:db}{rgb}  {0.9, 0.5, 0.0}
\definecolor{col:ours}{rgb}{0.0, 0.7, 0.0}

\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{darkbrown}{RGB}{121,37,0}

% Customized syntax highlighting for Haskell code snippets:
\colorlet{listing-comment}{gray}
\colorlet{operator-color}{darkbrown}

\lstdefinestyle{default}{
    basicstyle=\ttfamily\fontsize{8.7}{9.5}\selectfont,
    columns=fullflexible,
    commentstyle=\sffamily\color{black!50!white},
    escapechar=\#,
    framexleftmargin=1em,
    framexrightmargin=1ex,
    keepspaces=true,
    keywordstyle=\color{dkblue},
    mathescape,
    numbers=none,
    numberblanklines=false,
    numbersep=1.25em,
    numberstyle=\relscale{0.8}\color{gray}\ttfamily,
    showstringspaces=true,
    stepnumber=1,
    xleftmargin=1em
}

\lstdefinelanguage{custom-haskell}{
    language=Haskell,
    deletekeywords={lookup, delete, map, mapMaybe, Ord, Maybe, String, Just, Nothing, Int, Bool},
    keywordstyle=[2]\color{dkgreen},
    morekeywords=[2]{String, Map, Ord, Maybe, Int, Bool},
    morekeywords=[2]{Name, Expression, ESummary, PosTree, Structure, HashCode, VarMap},
    keywordstyle=[3]\color{dkcyan},
    literate=%
        {=}{{{\color{operator-color}=}}}1
        {|}{{{\color{operator-color}|}}}1
        {\\}{{{\color{operator-color}\textbackslash$\,\!$}}}1
        {.}{{{\color{operator-color}.}}}1
        {=>}{{{\color{operator-color}=>}}}1
        {->}{{{\color{operator-color}->}}}1
        {<-}{{{\color{operator-color}<-}}}1
        {::}{{{\color{operator-color}::}}}1
}

\lstset{style=default}
% Environment for code snippets
\lstnewenvironment{code}[1][]
  {\small\lstset{language=custom-haskell,#1}}
  {}

% Environment for example expressions
\lstnewenvironment{expression}[1][]
  {\small\lstset{#1}}
  {}

\begin{document}

\newcommand{\simon}[1]{{\bf SLPJ}: #1 {\bf End SLPJ}}


%% Title information
\title%[Short Title]
{Triemaps that match}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
%                                         %% can be repeated if necessary;
%                                         %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                         %% can be repeated if necessary;
%                                         %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Simon Peyton Jones}
\affiliation{
  \institution{Microsoft Research}
  % \streetaddress{21 Station Rd.}
  \city{Cambridge}
  % \postcode{CB1 2FB}
  \country{UK}
}
\email{simonpj@microsoft.com}

\author{Richard A.~Eisenberg}
\affiliation{
  \institution{Tweag I/O}
  \city{Cambridge}
  \country{UK}
}
\email{rae@richarde.dev}

\author{Josef Sveningsson}

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
TrieMaps are great.
\end{abstract}

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction} \label{sec:intro}

The designs of many programming languages include a feature where some concrete use of a construct is matched against a set of possible interpretations, where the possible interpretations might be defined in terms of variables to be instantiated at concrete usages. For example:
\begin{itemize}
\item Haskell's class instances work this way: the user defines instances (which may contain variables), and then concrete usage sites of class methods require finding an instance that applies.
\item Agda, Coq, and Idris all have implicit-argument features directly inspired by Haskell's class mechanism.
\item An extension to Haskell allows overloaded instances, where we select the most specific instance (that is, one that is a specialization of any other possible matching instance).
\item C++ and Java both support function overloading, where a usage site of a function must be matched against a choice of implementation. C++'s templates and Java's generics allow for variables to be used in the implementations. There are sometimes multiple implementations that match; both languages choose the most specific match (for an appropriate definition of "most specific").
\item C++ separately allows template specialization, where a templated definition can have concrete specializations. Once again, selection of these specializations depends on a "most-specific" relation appropriate to the case.
\item Scala? C\#?
\end{itemize}
Beyond features specified in a language's design, optimizations may require such a structure. For example, GHC's rewrite rules~\cite{rewrite-rules} requires a similar lookup to find a mapping from expressions to rules that may apply.

Our concern here is the efficient implementation of this matching
operation. That is, we wish to define a structure mapping keys to
arbitrary values. The keys are chosen from a type described by a
context-free grammar and thus comprise small trees. We assume a total
ordering on such trees. The challenge lies in the fact that we want
our structure to support wildcard variables, which represent any tree
at all. We will write such variables with Greek letters. Accordingly,
we can view a mapping \lstinline{alpha |-> v} as an infinite mapping, connecting
all possible trees to v, or we can have \lstinline{Maybe alpha |-> v2} map all
trees whose root is Maybe to the value v2. Combining these to `alpha
|-> v, Maybe alpha |-> v2` would map all trees to v, except those
trees that have Maybe at the root, which map to v2. Accordingly,
looking up in our structure find the most specific
match.\footnote{This aspect of our design is unforced. We could also
return all possible matches, instead of selecting the most
specific. See \cref{sec:most-specific}.}

Our contributions are as follows:

\begin{itemize}
\item We describe the language-agnostic Variable Trie-Map (VTM) data structure, with the semantics as described above (and made more precise in \cref{sec:vtm}). The keys in a VTM support local bound variables via on-the-fly conversion to de Bruijn levels, necessary to support polymorphic types or $\lambda$-expressions. Looking up in a VTM is linear in the size of the key, regardless of the size of the VTM itself. The operations on a VTM are proved to uphold the sensible properties described in \cref{sec:vtm-properties}.
\item Some languages require not only the matching behavior above, but also a \emph{unification} operation, where we find not only keys that match, but keys that would match if variables in the looked-up tree were further instantiated. \Cref{sec:unification} describes how we extend VTMs to support unification as well as matching.
\item While VTMs are time-efficient, they can be space-inefficient. \Cref{sec:path-compression} describes an easy optimization which drastically reduces the memory footprint of VTMs whose keys share little structure in common. This optimization shows a 30% geometric mean savings in the size of the structure GHC uses to look up rewrite rules.
\item Our work was motivated by quadratic behavior in GHC, observed when checking for instance consistency among imports. This became a problem in practice in Haskell's use at Facebook. We report on our implementation within GHC, showing that it achieves a 98% speedup against the previous (admittedly naive) implementation of instance tables.
\end{itemize}

\section{Job description}
\begin{figurebox}
\begin{code}
type XT v = Maybe v -> Maybe v

Map.empty  :: Map k v
Map.insert :: Ord k => k -> v -> Map k v
Map.lookup :: Ord k => k -> Map k v -> Maybe v
Map.alter  :: Ord k => k -> XT v -> Map k v -> Maybe v
Map.size   :: Map k v -> Int
Map.foldr  :: (v -> r -> r) -> r -> Map k v -> r
\end{code}
\caption{API for the containers library}
\label{fig:containers}
\end{figurebox}

Our general task is as follows: \emph{implement a finite mapping from keys to values,
in which the key type is some kind of tree}.
For example, an \lstinline{Expr} data type might be defined like this:
\begin{code}
  data Expr = Lit Lit
            | App Expr Expr
            | Lam  Var Expr
            | Var Var
\end{code}
Here \lstinline{Var} is the type of variables; which can be compared for
equality and used as the key of a finite map.  Literals, of type \lstinline{Lit},
include functions such as \lstinline{add}, and constants such as \lstinline{23}.
Neithe type is important for this paper, but for the sake of concretemess
you could imagine them both being simply a string:
\begin{code}
  type Var = String
  type Lit = String
\end{code}
The data type \lstinline{Expr} is capable of representing expressions like $add 2 3$
$\lambda x. add x 3$.  We will use this data type throughout the paper, because it
has all the features that occur in real expression data types: literals, variables,
binders, and nodes with multiple children.  A real-world compiler like GHC would have
many more constructors in the data type.

A finite map keyed by such expressions is extremely useful.
GHC uses such a map during its common sub-expression
elimination pass, where the map associates an
expression with the identifier bound to that expression; if the same
expression occurs again, we can look it up in the map, and replace the
expression with the variable.

GHC also does many lookups based on \emph{types} rather than
\emph{expressions}.  For example, when implementing type-class
instance lookup, or doing type-family reduction, GHC needs a map whose
key is a type.

What API might such a map have. We follow the design pattern of
the \lstinline{containers} library, whose key functions are given in \Cref{fig:containers},
and seek these basic operations:
\begin{code}
  type XT v = Maybe v -> Maybe v

  emptyEM  :: ExprMap v
  lookupEM :: Expr -> ExprMap v -> Maybe v
  alterEM  :: Expr -> XT v -> ExprMap v -> ExprMap v
\end{code}
The functions \lstinline{emptyEM} and \lstinline{lookupEM} should be
self-explanatory.  The function \lstinline{alterTM} is a standard
generalisation of \lstinline{insert}, in which the element to be
inserted is generalised to a function \lstinline{XT v}, an
abbreviation for \lstinline{Maybe v -> Maybe v}.  This function
transforms the existing value associated with key, if any (hence the
\lstinline{Maybe}), to a new value, with \lstinline{Nothing}
indicating deletion.  Given \lstinline{alterEM} we can easily define \lstinline{insertEM} adn \lstinline{deleteEM}:
\begin{code}
  insertEM :: Expr -> v -> ExprMap v -> ExprMap v
  insertEM e v = alterEM e (\_ -> Just v)

  deleteEM :: Expr -> ExprMap v -> ExprMap v
  deleteEM e = alterEM e (\_ -> Nothing)
\end{code}
We will add more functions later, as we go.

\subsection{Alpha-renaming}

Remember that the type \lstinline{Expr} is the \emph{key} of our \lstinline{ExprMap} type.
So we would expect insertion and lookup to be insensitive to
$\alpha$-renaming. For example suppose we insert a value with key
$(\lambda x. add x 3)$, and then look up the
key $(\lambda y. add y 3)$: we should
certainly expect to find the value we inserted, even though the name
of the $\lambda$-bound variable has changed.


\subsection{Matching}
In GHC we want more: we want to a lookup that does \emph{matching}.

\simon{Say more}.

\section{Non-solutions} \label{sec:ord}

At first sight the job can be done easily: define a total order on
\lstinline{Expr}, make it an instance of the class \lstinline{Ord},
and use a standard finite map library such as \lstinline{Data.Map}.
And indeed that works, but it is terribly slow.  A finite map is
implemented as a binary search tree; at every node of this tree, we compare the key (a \lstinline{Expr}, remember) with
a key stored at the node; if it is smaller, go left; if larger, go right. So each lookup
a (logarithmic) number of potentially-full-depth comparisons of two types.

Another possibility might be to hash the \lstinline{Expr} and use the
hash-code as the lookup key.  That would make lookup much faster, but
it requires at least two full traversals of the key for every lookup:
one to compute its hash code for every lookup, and a full equality
comparison on a ``hit'' because hash-codes can collide.  Moreover
hashing algorithms that respect $\alpha$-conversion are not trivial
\cite{alpha-hashing}.

\section{Tries}

A rather standard approach to a finite map in which the key has internal structure
is to use a \emph{trie} \cite{trie}.  Let us consider a simplified
form of expression:
\begin{code}
  data ExprS = LitS Lit | AppS ExprS ExprS
\end{code}
We have dropped variables and lambdas for now, to concentrate on the initial idea.

\subsection{The basic idea} \label{sec:alter}

Here is a trie-based implemenation for \lstinline{ExprS}:
\begin{code}
  data ExprSMap v = ESM { esm_lit :: Map Lit v
                        , esm_app :: ExprSMap (ExprSMap v) }
\end{code}
Here `Map Lit v` is any standard, existing finite map keyed by `Lit`.
There are many such finite maps available for an ordered type like `Lit`;
the `containers` package will do as well as any.

One way to understand this slightly odd data type is to study its lookup function:
\begin{code}
  lkExprS :: ExprS -> ExprSMap v -> Maybe v
  lkExprS e (ESM { esm_lit = m_lit, esm_app = m_app }
    = case e of
       LitS lit   -> Map.lookup lit m_lit
       AppS e1 e2 -> case lkExprS e1 m_app of
                       Nothing -> Nothing
                       Just m1 -> lkExprS e2 m1
\end{code}
The expression \lstinline{esm_lit m} selects the \lstinline{esm_lit} field from the record \lstinline{m}.  So the first
equation says that to look up a literal, just look that literal up in the \lstinline{esm_lit} field.
But if the expression is an \lstinline{(AppS e1 e2)} node, we first look up \lstinline{e1}
in the \lstinline{esm_app} field, \emph{which returns a finite map}.  We then look up \lstinline{e2}
in that map.  Each distinct \lstinline{e1} yields a different map in which to look up \lstinline{e2}.

Notice that in contrast to the approach of \Cref{sec:ord}, \emph{we never compare two expressions
for equality or ordering}.  We simply walk down the \lstinline{ExprMap} structure, guided
at each step by the next node in the target.  (We typically use the term ``target'' for the
key we are looking up in the finite map.)

Here is the code for \lstinline{alter}:
\begin{code}
  xtExprS  :: ExprS -> XT v -> ExprSMap v -> ExprSMap v
  xtExprS e xt m@(ESM { esm_lit = m_lit, esm_app = m_app }
    = case of
        LitS lit   -> Map.alter lit xt m_lit
        AppS e1 e2 -> xtExprS e1 (liftXT (xtExprS e2 xt)) m_app

  liftXT :: (ExprSMap v -> ExprSMap v) -> XT (ExprSMap)
  liftXT f Nothing  = Just (f empExprS)
  liftXT f (Just m) = Just (f m)
\end{code}
In the \lstinline{AppS} case we look up \lstinline{e1} in \lstinline{m_app};
we should find a \lstinline{TypeMap} there, which we want to alter with \lstinline{xt}.
We can do that with a recursive call to \lstinline{xtExprS}, using \lstinline{liftXT}
for impedence-matching.

Finally, we need an empty map:
\begin{code}
  empExprS :: ExprSMap v
  empExprS = ESM { esm_lit = Map.empty
                 , esm_app = empExprS }
\end{code}
It is interesting to note that \lstinline{empExprS} is an infinite, recursive structure:
the \lstinline{esm_app} field refers back to \lstinline{empExprS}.

These definitions are all extremely short and natural. But they conceal a hidden
complexity: they require polymorphic recursion. The recursive call to \lstinline{lkExprS e1}
instantiates \lstinline{v} to a differnet type than the parent function definition.
Haskell supports polymorphic recurision readily, provided you give type signature to
\lstinline{lkExprS}, but not all languages do.

\subsection{Folds and the empty map} \label{sec:fold}

Suppose we wanted to count the number of elements in the finite map; in \lstinline{containers}
this is the function \lstinline{Map.size} (\Cref{fig:containers}).  We might try
\begin{code}
  sizeExprS :: ExprSMap v -> Int
  sizeExprS (ESM { esm_lit = m_lit, esm_app = m_app })
    = Map.size m_lit + ???
\end{code}
We seem stuck because the size of the \lstinline{m_app} map is not what we want: rather,
we want to add up the sizes of its elements.   The right thing to do is to generalise to a fold:
\begin{code}
  foldrExprS :: (v -> r -> r) -> r -> ExprSMap v -> r
  foldrExprS k z (ESM { esm_lit = m_lit, esm_app = m_app })
    = Map.foldr k z1 m_lit
    where
      z1 = foldrExprS kapp z m_app
      kapp m1 r = foldrExprS k r m1
\end{code}
Here, in the binding for \lstinline{z1} we fold over \lstinline{m_app :: ExprSMap (ExprSMap v)}.
The function \lstinline{kapp} is combines the map we find with the accumulator, by again
folding over the map with \lstinline{foldrExprS}

But, alas, \lstinline{foldrExprS} will never terminate!  It always invokes itself immediately
(in \lstinline{z1}) on \lstinline{m_app}; but that invocation will again recursively invoke
\lstinline{foldrExprS}; and so on for ever.

The solution is simple: we just need an explicit representation of the empty map.
Here is one way to do it (we will see another in \Cref{sec:higher-order}:
\begin{code}
  data ExprSMap v = EmptyESM
                  | ESM { esm_lit :: Map Lit v
                        , esm_app :: ExprSMap (ExprSMap v) }

  empExprS :: ExprSMap v
  empExprS = EmptyESM

  foldrExprS :: (v -> r -> r) -> r -> ExprSMap v -> r
  foldrExprS k z EmptyESM
    = z
  foldrExprS k z (ESM { esm_lit = m_lit, esm_app = m_app })
    = Map.foldr k z1 m_lit
    where
      z1 = foldrExprS kapp z m_app
      kapp m1 r = foldrExprS k r m1
\end{code}
Thus equipped with a fold, we can easily define the size function, and another
that returns the range of the map:
\begin{code}
  sizeExprS :: ExprSMap v -> Int
  sizeExprS = foldrExprS (\_ n -> n+1) 0

  elemsExprS :: ExprSMap v -> [v]
  elemsExprS = foldrExprS (:) []
\end{code}

\subsection{Singleton maps} \label{sec:singleton}

Suppose we start with an empty map, and insert a value
with a key (an \lstinline{Expr}) that is large, say
\begin{code}
  App (App (Lit "f") (Lit "2")) (Lit "3"))
\end{code}
Looking at the code
for \lstinline{xtExprS} in \Cref{sec:alter}, you can see that
because there is an \lstinline{App} at the root, we will build an
\lstinline{ESM} record with an empty \lstinline{esm_lit} and an
\lstinline{esm_app} field that is... another \lstinline{ESM}
record.  Again the \lstinline{esm_lit} field will contain an
empty map, while the \lstinline{esm_app} field is a further \lstinline{ESM} record.

In effect, the key is linearised into a chain of \lstinline{ESM} records.
This is great when there are a lot of keys with shared structure, but
once we are into a sub-tree that represents a single key-value pair it is
a rather inefficient way to represent the key.  So a simple idea is this:
when a \lstinline{ExprMap} represents a single key-value pair, represent it
as directly a key-value pair!  Like this:
\begin{code}
  data ExprSMap v = EmptyESM
                  | SingleESM ExprS v
                  | ESM { esm_lit :: Map Lit v
                        , esm_app :: ExprSMap (ExprSMap v) }
\end{code}
The code for lookup practically writes itself:
\begin{code}
  lkExprS :: ExprS -> ExprSMap v -> Maybe v
  lkExprS e EmptyESM
    = Nothing
  lkExprS e1 (SingleESM e2 v2)
  = if e1 == e2 then Just e2
                else Nothing
  lkExprS e (ESM { esm_lit = m_lit, esm_app = m_app }
    = case e of
       LitS lit   -> Map.lookup lit m_lit
       AppS e1 e2 -> case lkExprS e1 m_app of
                       Nothing -> Nothing
                       Just m1 -> lkExprS e2 m1
\end{code}
Notice that in the \lstinline{SingleESM} case we need equality on \lstinline{Expr},
to tell if the key being looked up, \lstinline{k1} is the same as the key in
the \lstinline{SingleESM}, namely \lstinline{k2}.

The code for alter is more interesting, becuase it governs the shift from
\lstinline{EmptyESM} to \lstinline{SingleESM} and thence for \lstinline{ESM}:
\begin{code}
  xtExprS  :: ExprS -> XT v -> ExprSMap v -> ExprSMap v
  xtExprS e xt EmptyESM
    = case xt Nothing of
        Nothing -> EmptyESM
        Just v  -> SingleESM e v

  xtExprS e xt m@(SingleESM key v1)
    | e == key
    = case xt (Just v1) of
        Nothing -> EmptyESM
        Just v2  -> SingleESM e v2
    | otherwise
    = case xt Nothing of
        Nothing -> m
        Just v2 -> xtExprS key (\_ -> Just v1) $
                   xtExprS e   (\_ -> Just v2) $
                   ESM { esm_lit = Map.empty, esm_app = emptyESM }

  xtExprS e xt m@(ESM { esm_lit = m_lit, esm_app = m_app }
    = case of
        LitS lit   -> Map.alter lit xt m_lit
        AppS e1 e2 -> xtExprS e1 (liftXT (xtExprS e2 xt)) m_app

  liftXT :: (ExprSMap v -> ExprSMap v) -> XT (ExprSMap)
  liftXT f Nothing  = Just (f empExprS)
  liftXT f (Just m) = Just (f m)
\end{code}
Although we began by speaking of a map containing only one key-value pair,
this representation uses \lstinline{ESM} while there are keys that share structure,
but as soon as we get into a sub-treee where there is no overlap, we revert
to \lstinline{SingleESM}.

This optimisation makes a big difference in practice: see \Cref{sec:results}.

\subsection{Maps of higher kinds}

\end{document}
